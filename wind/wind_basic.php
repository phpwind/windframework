<?php   interface IWindConfigParser { public function parse($configPath, $alias = '', $append = ''); }   class WindConfigParser implements IWindConfigParser { const CONFIG_XML = 'XML'; const CONFIG_PHP = 'PHP'; const CONFIG_INI = 'INI'; const CONFIG_PROPERTIES = 'PROPERTIES'; const WIND_ROOT = 'wind'; private $configParsers = array(); public function __construct() {} public function parse($configPath, $alias = '', $append = '') { $config = array(); $alias = trim($alias); $append = !$append ? '' : trim($append); $alias && $cacheFileName = ($append ? $this->buildCacheFilePath($append) : $this->buildCacheFilePath($alias)); if ($alias) { $config = $this->getCacheContent($cacheFileName); if (isset($config[$alias]) && !$this->needCompiled()) { return $config[$alias]; } } if (!($configPath = trim($configPath))) throw new WindException('Please input the file path!'); $result = $this->doParser($configPath, $this->getConfigFormat($configPath)); if (!$alias) return $result; $config[$alias] = $result; $this->saveConfigFile($cacheFileName, $config); return $result; } private function getCacheContent($file) { $content = array(); if (is_file($file)) $content = include ($file); return is_array($content) ? $content : array(); } private function createParser($type) { switch ($type) { case self::CONFIG_XML: Wind::import("WIND:component.parser.WindXmlParser"); return new WindXmlParser(); break; case self::CONFIG_INI: Wind::import("WIND:component.parser.WindIniParser"); return new WindIniParser(); break; case self::CONFIG_PROPERTIES: Wind::import("WIND:component.parser.WindPropertiesParser"); return new WindPropertiesParser(); break; default: throw new WindException('init config parser error.'); break; } } private function doParser($configFile, $type) { if (!$configFile) return array(); if (!is_file($configFile)) throw new WindException('The file <' . $configFile . '> is not exists'); if ($type == 'PHP') { $config = include ($configFile); return (isset($config['wind'])) ? $config['wind'] : $config; } if (!isset($this->configParsers[$type])) { $this->configParsers[$type] = $this->createParser($type); } return $this->configParsers[$type]->parse($configFile); } private function needCompiled() { if (IS_DEBUG && is_dir(COMPILE_PATH)) return true; return false; } private function getConfigFormat($configPath) { if ($configPath === '') return self::CONFIG_XML; $format = strtoupper(trim(strrchr($configPath, '.'), '.')); if (!in_array($format, $this->getConfigFormatList())) { throw new WindException("The format of the config file doesn't sopported yet!"); } return $format; } private function saveConfigFile($filename, $data) { if (!$filename || !$data || !is_dir(COMPILE_PATH)) return false; Wind::import('COM:utility.WindFile'); return WindFile::savePhpData($filename, $data); } private function buildCacheFilePath($fileName) { return rtrim(COMPILE_PATH, '/') . D_S . strtolower($fileName) . '.php'; } private function getConfigFormatList() { return array( self::CONFIG_XML, self::CONFIG_PHP, self::CONFIG_INI, self::CONFIG_PROPERTIES); } public function __destruct() { $this->configParser = array(); } }   class WindConfig { protected $configParser = null; protected $cacheName; protected $append; protected $config = array(); public function __construct($config, $configParser = null, $cacheName = '', $append = false) { $this->setConfigParser($configParser); $this->setCacheName($cacheName); $this->setAppend($append); $this->initConfig($config); } public function getConfig($configName = '', $subConfigName = '', $config = array(), $default = null) { if (!$config) $config = $this->config; if ($configName === '') return $config; $_config = $default; if (isset($config[$configName])) { $_config = $config[$configName]; } if ($subConfigName === '') return $_config; $_subConfig = $default; if (is_array($_config) && isset($_config[$subConfigName])) { $_subConfig = $_config[$subConfigName]; } return $_subConfig; } protected function initConfig($config) { if (!$config) return; if (!is_array($config)) { $config = $this->parseConfig($config, $this->getCacheName(), $this->getAppend()); } $this->setConfig($config); } protected function parseConfig($config, $cacheName, $append) { if ($this->getConfigParser() === null) { throw new WindException('configParser is null.'); } return $this->getConfigParser()->parse($config, $cacheName, $append); } public function setConfig($config, $merage = false) { if (!is_array($config)) throw new WindException('config error.'); if ($merage) $this->config = array_merge($this->config, $config); else $this->config = $config; } public function getConfigParser() { return $this->configParser; } public function setConfigParser($configParser) { if ($this->configParser || $configParser == null) return; $this->configParser = $configParser; } public function getCacheName() { return $this->cacheName; } public function getAppend() { return $this->append; } public function setCacheName($cacheName) { $this->cacheName = $cacheName; } public function setAppend($append) { $this->append = $append; } }   Wind::import('WIND:core.config.WindConfig'); class WindSystemConfig extends WindConfig { const CLASS_PATH = 'class'; const PATH = 'path'; const VALUE = 'value'; const IMPORTS = 'imports'; const IMPORTS_RESOURCE = 'resource'; const IMPORTS_IS_APPEND = 'is-append'; const WEB_APPS = 'web-apps'; const WEB_APP_ROOT_PATH = 'root-path'; const WEB_APP_FACTORY = 'factory'; const WEB_APP_FACTORY_CLASS_DEFINITION = 'class-definition'; const WEB_APP_FILTER = 'filters'; const WEB_APP_ROUTER = 'router'; const WEB_APP_MODULE = 'modules'; const WEB_APP_TEMPLATE = 'template'; protected $appName = ''; protected $imports = array(); public function __construct($config, $configParser, $appName) { $cacheName = $appName . '_config'; $this->appName = $appName; parent::__construct($config, $configParser, $cacheName); } public function getConfig($configName = '', $subConfigName = '', $config = array(), $default = null) { $imports = parent::getConfig(self::IMPORTS); if (key_exists($configName, (array) $imports)) { return $this->parseImport($configName); } return parent::getConfig($configName, $subConfigName, $config, $default); } public function getAppName() { return $this->appName; } public function getAppClass() { $_config = $this->getConfig(self::WEB_APPS, $this->appName); $_tmp = $this->getConfig(self::CLASS_PATH, '', $_config); return $_tmp ? $_tmp : COMPONENT_WEBAPP; } public function getRootPath($appName = '') { if ($appName === '') $appName = $this->appName; $_tmp = $appName . '_RootPath'; if (!isset($this->$_tmp)) { $appConfig = $this->getConfig(self::WEB_APPS, $appName); if (isset($appConfig[self::WEB_APP_ROOT_PATH]) && !empty($appConfig[self::WEB_APP_ROOT_PATH])) $rootPath = $appConfig[self::WEB_APP_ROOT_PATH]; else $rootPath = dirname($_SERVER['SCRIPT_FILENAME']); $this->$_tmp = $rootPath; } return $this->$_tmp; } public function getFactory($name = '') { $_config = $this->getConfig(self::WEB_APPS, $this->appName); return $this->getConfig(self::WEB_APP_FACTORY, $name, $_config); } public function getFilterClass() { return $this->getFilters(self::CLASS_PATH); } public function getFilters($name = '') { $_config = $this->getConfig(self::WEB_APPS, $this->appName); return $this->getConfig(self::WEB_APP_FILTER, $name, $_config); } public function getRouterClass() { return $this->getRouter(WIND_CONFIG_CLASS); } public function getRouter($name = '') { $_config = $this->getConfig(self::WEB_APPS, $this->appName); $_router = $this->getConfig(self::WEB_APP_ROUTER, $name, $_config); return $_router ? $_router : COMPONENT_ROUTER; } public function getModules($name = '') { $_config = $this->getConfig(self::WEB_APPS, $this->appName); return $this->getConfig(self::WEB_APP_MODULE, $name, $_config); } public function getModuleViewClassByModuleName($name, $default = '') { $module = $this->getModules($name); return $this->getConfig('view', WIND_CONFIG_CLASS, $module, $default); } public function getModuleViewConfigByModuleName($name, $default = '') { $module = $this->getModules($name); return $this->getConfig('view', WIND_CONFIG_CONFIG, $module, $default); } public function getModuleErrorHandlerByModuleName($name, $default = '') { $module = $this->getModules($name); return $this->getConfig('error-handler', WIND_CONFIG_CLASS, $module, $default); } public function getModuleControllerPathByModuleName($name, $default = '') { $module = $this->getModules($name); return $this->getConfig(WIND_CONFIG_CLASSPATH, '', $module, $default); } public function getModuleControllerSuffixByModuleName($name, $default = '') { $module = $this->getModules($name); return $this->getConfig('controller-suffix', WIND_CONFIG_VALUE, $module, $default); } public function getTemplate($name = '') { return $this->getConfig(self::TEMPLATE, $name); } public function getViewerResolvers($name = '') { return $this->getConfig(self::VIEWER_RESOLVERS, $name); } public function getApplications($name = '') { return $this->getConfig(self::APPLICATIONS, $name); } public function getErrorMessage($name = '') { return $this->getConfig(self::ERROR, $name); } protected function parseImport($name) { if (!isset($this->imports[$name])) { $imports = $this->getConfig(self::IMPORTS); if (!isset($imports[$name])) return array(); $import = $imports[$name]; $config = array(); if (is_array($import) && !empty($import)) { $configPath = Wind::getRealPath($import[self::IMPORTS_RESOURCE]); if (!isset($import[self::IMPORTS_IS_APPEND]) || $import[self::IMPORTS_IS_APPEND] === 'true') { $append = $this->cacheName; } elseif ($import[self::IMPORTS_IS_APPEND] === 'false' || $import[self::IMPORTS_IS_APPEND] === '') { $append = false; } else { $append = $import[self::IMPORTS_IS_APPEND]; } $cacheName = $append ? $name : $this->appName . '_' . $name . '_config'; $config = $this->parseConfig($configPath, $cacheName, $append); } $this->imports[$name] = $config; } return $this->imports[$name]; } }   class WindException extends Exception { const ERROR_SYSTEM_ERROR = '0'; const ERROR_CLASS_NOT_EXIST = '100'; const ERROR_CLASS_TYPE_ERROR = '101'; const ERROR_CLASS_METHOD_NOT_EXIST = '102'; const ERROR_OBJECT_NOT_EXIST = '103'; const ERROR_PARAMETER_TYPE_ERROR = '110'; const ERROR_CONFIG_ERROR = '120'; const ERROR_RETURN_TYPE_ERROR = '130'; private $innerException = null; public function __construct($message = '', $code = 0, Exception $innerException = null) { $message = $this->buildMessage($message, $code); parent::__construct($message, $code); $this->innerException = $innerException; } public function getInnerException() { return $this->innerException; } public function getStackTrace() { if ($this->innerException) { $thisTrace = $this->getTrace(); $class = __CLASS__; $innerTrace = $this->innerException instanceof $class ? $this->innerException->getStackTrace() : $this->innerException->getTrace(); foreach ($innerTrace as $trace) $thisTrace[] = $trace; return $thisTrace; } else { return $this->getTrace(); } return array(); } public function buildMessage($message, $code) { $message = str_replace(array("<br />", "<br>", "\r\n"), '', $message); eval('$message="' . addcslashes($this->messageMapper($code), '"') . '";'); return $message; } protected function messageMapper($code) { $messages = array(self::ERROR_SYSTEM_ERROR => 'System error \'$message\'.', self::ERROR_CLASS_TYPE_ERROR => 'Incorrect class type \'$message\'.', self::ERROR_CLASS_NOT_EXIST => 'Unable to create instance for \'$message\' , class is not exist.', self::ERROR_CLASS_METHOD_NOT_EXIST => 'Unable to access the method \'$message\' in current class , the method is not exist or is protected.', self::ERROR_OBJECT_NOT_EXIST => 'Unable to access the object in current class \'$message\' ', self::ERROR_CONFIG_ERROR => 'Incorrect config. the config about \'$message\' error.', self::ERROR_PARAMETER_TYPE_ERROR => 'Incorrect parameter type \'$message\'.', self::ERROR_RETURN_TYPE_ERROR => 'Incorrect return type for \'$message\'.'); return isset($messages[$code]) ? $messages[$code] : '$message'; } }  Wind::import('WIND:core.exception.WindException'); class WindActionException extends WindException { private $error; public function __construct($error) { $this->setError($error); parent::__construct(''); } protected function messageMapper($code) { $messages = array(); return isset($messages[$code]) ? $messages[$code] : '$message'; } public function getError() { return $this->error; } public function setError($error) { $this->error = $error; } }    Wind::import('WIND:core.exception.WindException'); class WindFinalException extends WindException {}    interface IWindFactory { public function getInstance($classAlias); public function getPrototype($classAlias); static public function createInstance($className, $args = array()); }   interface IWindClassProxy { const EVENT_TYPE_METHOD = 'method'; const EVENT_TYPE_SETTER = 'setter'; const EVENT_TYPE_GETTER = 'getter'; public function _getReflection(); public function _getInstance(); public function registerEventListener($event, $listener, $type = self::EVENT_TYPE_METHOD); }    class WindClassProxy implements IWindClassProxy { private $_interceptorChain = 'WIND:core.filter.WindHandlerInterceptorChain'; protected $_attributes = array(); protected $_className = ''; protected $_classPath = ''; protected $_reflection = null; protected $_instance = null; protected $_listener = array(); public function __construct($targetObj = null, $args = array()) { $this->initClassProxy($targetObj, $args); } public function registerEventListener($event, $listener, $type = self::EVENT_TYPE_METHOD) { if (!in_array($type, array(self::EVENT_TYPE_METHOD, self::EVENT_TYPE_GETTER, self::EVENT_TYPE_SETTER))) { throw new WindException( '[core.factory.proxy.WindClassProxy.registerEventListener] Unsupport event type:' . $type, WindException::ERROR_PARAMETER_TYPE_ERROR); } !isset($this->_listener[$type][$event]) && $this->_listener[$type][$event] = array(); array_push($this->_listener[$type][$event], $listener); } public function __set($propertyName, $value) { $property = $this->_getReflection()->getProperty($propertyName); if (!$property || !$property->isPublic()) { throw new WindException('undefined property name. '); } $listeners = $this->_getListenerByType(self::EVENT_TYPE_SETTER, $propertyName); if (empty($listeners)) return call_user_func_array(array($this, '_setProperty'), array($propertyName, $value)); $interceptorChain = $this->_getInterceptorChain($propertyName); $interceptorChain->addInterceptors($listeners); $interceptorChain->setCallBack(array($this, '_setProperty'), array($propertyName, $value)); return $interceptorChain->getHandler()->handle($value); } public function __get($propertyName) { $property = $this->_getReflection()->getProperty($propertyName); if (!$property || !$property->isPublic()) { throw new WindException('undefined property name. '); } $listeners = $this->_getListenerByType(self::EVENT_TYPE_GETTER, $propertyName); if (empty($listeners)) return call_user_func_array(array($this, '_getProperty'), array($propertyName)); $interceptorChain = $this->_getInterceptorChain($propertyName); $interceptorChain->addInterceptors($listeners); $interceptorChain->setCallBack(array($this, '_getProperty'), array($propertyName)); return $interceptorChain->getHandler()->handle($propertyName); } public function __call($methodName, $args) { $listeners = $this->_getListenerByType(self::EVENT_TYPE_METHOD, $methodName); if (empty($listeners)) return call_user_func_array(array($this->_getInstance(), $methodName), (array) $args); $interceptorChain = $this->_getInterceptorChain($methodName); $interceptorChain->addInterceptors($listeners); $interceptorChain->setCallBack(array($this->_getInstance(), $methodName), $args); return call_user_func_array(array($interceptorChain->getHandler(), 'handle'), (array) $args); } protected function initClassProxy($targetObject, $args = array()) { try { if (is_object($targetObject)) { $this->_setClassName(get_class($targetObject)); $this->_instance = $targetObject; } elseif (is_string($targetObject) && !empty($targetObject)) { $_className = Wind::import($targetObject); $this->_setClassName($_className); } else throw new WindException($this->_className, WindException::ERROR_CLASS_NOT_EXIST); $types = array(self::EVENT_TYPE_METHOD, self::EVENT_TYPE_GETTER, self::EVENT_TYPE_SETTER); foreach ($types as $type) { $this->_listener[$type] = array(); } $reflection = new ReflectionClass($this->_className); if ($reflection->isAbstract() || $reflection->isInterface()) { throw new WindException($this->_className, WindException::ERROR_CLASS_NOT_EXIST); } $this->_reflection = $reflection; if ($this->_instance !== null) return; $this->_instance = call_user_func_array(array($this->_reflection, 'newInstance'), $args); } catch (Exception $e) { Wind::log( '[core.factory.proxy.WindClassProxy.initClassProxy] Initialization proxy failed.' . $e->getMessage(), WindLogger::LEVEL_DEBUG, 'wind.core'); } } private function _getInterceptorChain($event = '') { $interceptorChain = WindFactory::createInstance($this->_interceptorChain); if ($interceptorChain && $interceptorChain instanceof WindHandlerInterceptorChain) { $interceptorChain->setAttribute($this->_getAttribute()); $interceptorChain->setAttribute('instance', $this->_getInstance()); $interceptorChain->setAttribute('event', array($this->_getClassName(), $event)); return $interceptorChain; } else throw new WindException('unable to create interceptorChain.'); } private function _getListenerByType($type, $subType) { $listener = array(); if (isset($this->_listener[$type]) && isset($this->_listener[$type][$subType])) { $listener = $this->_listener[$type][$subType]; } return $listener; } public function _getInstance() { return $this->_instance; } public function _getReflection() { if ($this->_reflection instanceof ReflectionClass) return $this->_reflection; else throw new WindException(get_class($this) . '->_reflection, ' . gettype($this->_reflection), WindException::ERROR_CLASS_TYPE_ERROR); } public function _getClassName() { return $this->_className; } public function _getClassPath() { return $this->_classPath; } public function _setClassName($className) { $this->_className = $className; } public function _setClassPath($classPath) { $this->_setClassName(Wind::import($classPath)); $this->_classPath = $classPath; } public function _setProperty($propertyName, $value) { $this->_getInstance()->$propertyName = $value; return true; } public function _getProperty($propertyName) { return $this->_getInstance()->$propertyName; } public function _getAttribute($alias = '') { if ($alias === '') return $this->_attributes; else return isset($this->_attributes[$alias]) ? $this->_attributes[$alias] : null; } public function _setAttribute($alias, $object = null) { if (is_array($alias)) $this->_attributes += $alias; elseif (is_string($alias)) $this->_attributes[$alias] = $object; } }    class WindClassDefinition { const NAME = 'name'; const PATH = 'path'; const FACTORY_METHOD = 'factory-method'; const INIT_METHOD = 'init-method'; const SCOPE = 'scope'; const PROPERTIES = 'properties'; const CONSTRUCTOR_ARG = 'constructor-arg'; const REF = 'ref'; const VALUE = 'value'; const DELAY = 'delay'; const PROXY = 'proxy'; const CONFIG = 'config'; const RESOURCE = 'resource'; const SCOPE_SINGLETON = 'singleton'; const SCOPE_PROTOTYPE = 'prototype'; const SCOPE_REQUEST = 'request'; protected $proxyClass = 'WIND:core.factory.proxy.WindClassProxy'; protected $config; protected $proxy; protected $className; protected $alias; protected $path; protected $scope; protected $factoryMethod; protected $initMethod; protected $constructArgs = array(); protected $properties = array(); protected $classDefinition; private $instance = null; public function __construct($classDefinition = array()) { $this->init($classDefinition); } public function getInstance($factory, $args = array()) { if ($instance = $this->executeFactoryMethod($args)) return $instance; switch ($this->scope) { case 'prototype': return $this->createInstanceWithPrototype($factory, $args); default: return $this->createInstanceWithSingleton($factory, $args); } } protected function createInstanceWithPrototype($factory, $args) { return $this->createInstance($factory, $args); } protected function createInstanceWithSingleton($factory, $args) { $_instance = $this->createInstance($factory, $args); $factory->setSingled($this->getAlias(), $_instance); return $_instance; } protected function createInstance($factory, $args) { $args = $this->buildConstructArgs($factory, $args); $instance = $factory->createInstance($this->getClassName(), $args); if ($instance instanceof WindModule) { $this->buildConfig($instance, $factory); $this->buildProperties($instance, $factory); $this->executeInitMethod($instance); $this->setHiddenProperty($instance, $factory); $instance = $this->setProxyForClass($instance, $factory); } return $instance; } protected function buildConfig($instance, $factory) { if (!$config = $this->getConfig()) return; if (isset($config[self::RESOURCE])) { $config = $config[self::RESOURCE]; } $instance->setConfig($config); } protected function setHiddenProperty($instance, $factory) { $instance->systemConfig = Wind::getApp()->getWindSystemConfig(); $instance->request = Wind::getApp()->getRequest(); $instance->response = Wind::getApp()->getResponse(); $instance->systemFactory = $factory; } protected function setProxyForClass($instance, $factory) { if (!($proxy = $this->getProxy()) || $proxy === 'false' || $proxy === false) return $instance; if ($proxy === 'true' || $proxy === true) $proxy = $this->proxyClass; $proxy = $factory->createInstance($proxy, array($instance)); if ($proxy !== null) return $proxy; Wind::log( '[core.factory.WindClassDefinition.setProxyForClass] create proxy for ' . $this->getClassName() . ' fail.', WindLogger::LEVEL_DEBUG, 'wind.core'); throw new WindException( '[core.factory.WindClassDefinition.setProxyForClass] create proxy for ' . $this->getClassName() . ' fail.', WindException::ERROR_SYSTEM_ERROR); } private function executeInitMethod($instance) { try { if (!($initMethod = $this->getInitMethod())) return; return call_user_func_array(array($instance, $initMethod), array()); } catch (Exception $e) { throw new WindException( '[core.factory.WindClassDefinition.executeInitMethod] (' . $this->getClassName() . '->' . $initMethod . '()) "' . $e->getMessage() . '"', WindException::ERROR_CLASS_METHOD_NOT_EXIST); } } protected function buildConstructArgs($factory, $args) { if ($args) return $args; $subDefinitions = $this->getConstructArgs(); $_tmp = array(); foreach ($subDefinitions as $key => $subDefinition) { if (isset($subDefinition[self::VALUE])) { $_tmp[$key] = $subDefinition[self::VALUE]; } elseif (isset($subDefinition[self::REF])) $_tmp[$key] = $factory->getInstance($subDefinition[self::REF]); } return $_tmp; } protected function buildProperties($instance, $factory) { if (!$subDefinitions = $this->getPropertys()) return; foreach ($subDefinitions as $key => $subDefinition) { $_value = ''; if (isset($subDefinition[self::VALUE])) $_value = $subDefinition[self::VALUE]; if ($_value) { $_setter = 'set' . ucfirst(trim($key, '_')); call_user_func_array(array($instance, $_setter), array($_value)); } } $instance->setDelayAttributes($subDefinitions); } protected function executeFactoryMethod($args) { try { if (!($factoryMethod = $this->getFactoryMethod())) return null; return call_user_func_array(array($this->getClassName(), $factoryMethod), $args); } catch (Exception $e) { throw new WindException( '[core.factory.WindClassDefinition.executeFactoryMethod] (' . $this->getClassName() . '->' . $factoryMethod . ')', WindException::ERROR_CLASS_METHOD_NOT_EXIST); } } protected function init($classDefinition) { try { if (empty($classDefinition)) return; foreach ($classDefinition as $key => $value) { if (strpos($key, '-') !== false) { list($_s1, $_s2) = explode('-', $key); $_s1 = ucfirst($_s1); $_s2 = ucfirst($_s2); $_setter = 'set' . $_s1 . $_s2; } else $_setter = 'set' . ucfirst($key); call_user_func_array(array($this, $_setter), array($value)); } $this->setClassDefinition($classDefinition); } catch (Exception $e) { throw new WindException("[core.factory.WindClassDefinition.init]" . $e->getMessage(), WindException::ERROR_SYSTEM_ERROR); } } public function getClassName() { if (!$this->className) { $this->className = Wind::import($this->getPath()); } return $this->className; } public function getAlias() { return $this->alias; } public function getPath() { return $this->path; } public function getScope() { return $this->scope; } public function setClassName($className) { $this->className = $className; } public function setAlias($alias) { $this->alias = $alias; } public function setPath($path) { $this->path = $path; } public function setScope($scope) { $this->scope = strtolower($scope); } public function getConstructArgs() { return $this->constructArgs; } public function getPropertys() { return $this->properties; } public function getClassDefinition() { return $this->classDefinition; } public function setConstructArgs($constructArgs) { if (is_array($constructArgs) && !empty($constructArgs)) $this->constructArgs += $constructArgs; } public function setProperties($properties) { if (!is_array($properties)) return; $this->properties = array_merge($this->properties, $properties); } public function setClassDefinition($classDefinition) { $this->classDefinition = $classDefinition; } public function getFactoryMethod() { return $this->factoryMethod; } public function getInitMethod() { return $this->initMethod; } public function setFactoryMethod($factoryMethod) { $this->factoryMethod = $factoryMethod; } public function setInitMethod($initMethod) { $this->initMethod = $initMethod; } public function getProxy() { return $this->proxy; } public function setProxy($proxy) { $this->proxy = $proxy; } public function getConfig() { return $this->config; } public function setConfig($config) { $this->config = $config; } }   class WindFactory implements IWindFactory { protected $classDefinitionType = 'WIND:core.factory.WindClassDefinition'; protected $classDefinitions = array(); protected $instances = array(); public function __construct($classDefinitions = array()) { $this->loadClassDefinitions($classDefinitions); } public function getInstance($alias) { if (isset($this->instances[$alias])) return $this->instances[$alias]; if (!$classDefinition = $this->getClassDefinitionByAlias($alias)) return null; $args = func_get_args(); unset($args[0]); return $classDefinition->getInstance($this, $args); } public function getPrototype($alias) { $instance = $this->getInstance($alias); if ($instance === null) return null; return clone $instance; } static public function createInstance($className, $args = array()) { try { if (!$className) return null; if (strpos($className, ':') !== false) $className = Wind::import($className); $reflection = new ReflectionClass($className); if ($reflection->isAbstract() || $reflection->isInterface()) return null; Wind::log('[core.factory.WindFactory.createInstance] create instance:' . $className, WindLogger::LEVEL_INFO, 'core.factory'); return call_user_func_array(array($reflection, 'newInstance'), (array) $args); } catch (Exception $e) { throw new WindException($className, WindException::ERROR_CLASS_NOT_EXIST); } } public function setSingled($classAlias, $instance) { Wind::log('[core.factory.WindFactory.createInstance] create singled instance:' . $classAlias, WindLogger::LEVEL_INFO, 'core.factory'); $this->instances[$classAlias] = $instance; } protected function getClassDefinitionByAlias($classAlias) { if (!($definition = $this->classDefinitions[$classAlias])) return null; if ($definition instanceof WindClassDefinition) return $definition; $classDefinition = self::createInstance($this->classDefinitionType, array($definition)); $classDefinition->setAlias($classAlias); $this->addClassDefinitions($classDefinition); return $classDefinition; } public function addClassDefinitions($classDefinition) { if ($classDefinition instanceof WindClassDefinition) { $alias = $classDefinition->getAlias(); $this->classDefinitions[$alias] = $classDefinition; } elseif (is_array($classDefinition)) { foreach ($classDefinition as $value) $this->addClassDefinitions($value); } } public function checkAlias($alias) { return isset($this->classDefinitions[$alias]); } protected function loadClassDefinitions($classDefinitions) { if (is_array($classDefinitions)) $this->classDefinitions = $classDefinitions; else throw new WindException('[core.factory.WindFactory.loadClassDefinitions]', WindException::ERROR_PARAMETER_TYPE_ERROR); } }  Wind::import('COM:utility.WindUtility'); class WindModule { private $_config = null; private $_array = array(); protected $_typeValidation = false; private $delayAttributes = array(); public function __set($propertyName, $value) { if (!$this->validatePropertyName($propertyName)) { $_setter = 'set' . ucfirst($propertyName); if (method_exists($this, $_setter)) $this->$_setter($value); else Wind::log('[core.WindModule.__set] both of property and setter are not exist. ' . $propertyName, WindLogger::LEVEL_DEBUG, 'wind.core'); } else $this->$propertyName = $value; } public function __get($propertyName) { if (!$this->validatePropertyName($propertyName)) { $_getter = 'get' . ucfirst($propertyName); if (method_exists($this, $_getter)) return $this->$_getter(); else Wind::log('[core.WindModule.__set] both of property and getter are not exist. ' . $propertyName, WindLogger::LEVEL_DEBUG, 'wind.core'); } else return $this->$propertyName; } public function __call($methodName, $args) { $_prefix = substr($methodName, 0, 4); $_propertyName = substr($methodName, 4); $_propertyName = WindUtility::lcfirst($_propertyName); if ($_prefix == '_set') { $this->$_propertyName = $args[0]; } elseif ($_prefix == '_get') { if (property_exists($this, $_propertyName) && $this->$_propertyName) { return $this->$_propertyName; } if (isset($this->delayAttributes[$_propertyName])) { $_instance = null; $_property = $this->delayAttributes[$_propertyName]; if (isset($_property[WindClassDefinition::REF])) { $_ref = $_property[WindClassDefinition::REF]; if ($this->getSystemFactory()->checkAlias($_ref)) $_instance = $this->getSystemFactory()->getInstance($_ref); else $_instance = $this->getSystemFactory()->createInstance($_ref); } $this->$_propertyName = $_instance; Wind::log("[core.WindMOdule.__call] create property $_propertyName fail.", WindLogger::LEVEL_DEBUG, 'wind.core'); } Wind::log("[core.WindModule.__call] attribute is not exist.  				(" . $methodName . ")", WindLogger::LEVEL_DEBUG, 'wind.core'); return $this->$_propertyName; } throw new WindException('[core.WindModule.__call] ' . get_class($this) . '->' . $methodName . '()', WindException::ERROR_CLASS_METHOD_NOT_EXIST); } public function __clone() { foreach ($this->writeTableCloneProperty() as $value) { if (!is_object($this->$value) || !isset($this->$value)) { Wind::log( "[core.WindModule.__clone] unexcepted value type or the property  					is not setted.(" . $value . ") need an object type in here. 					", WindLogger::LEVEL_DEBUG, 'wind.core'); continue; } $this->$value = clone $this->$value; } } public function toArray() { if (empty($this->_array)) { $reflection = new ReflectionClass(get_class($this)); $properties = $reflection->getProperties(); $_result = array(); foreach ($properties as $property) { $_propertyName = $property->name; $_result[$_propertyName] = $this->$_propertyName; } $this->_array = $_result; } return $this->_array; } protected function validatePropertyName($propertyName, $value = null) { if (isset($this->delayAttributes[$propertyName])) { Wind::log('[core.WindModule.validatePropertyName] is a delay property  (' . $propertyName . ')', WindLogger::LEVEL_DEBUG, 'wind.core'); return true; } if (!($_writeTableProperties = $this->writeTableForProperty())) { Wind::log( "[core.WindModule.validatePropertyName]  				writeTableForProperty is empty or your input is not exists. 				(" . $propertyName . ")", WindLogger::LEVEL_DEBUG, 'wind.core'); return false; } if (!array_key_exists($propertyName, $_writeTableProperties)) { Wind::log( "[core.WindModule.validatePropertyName]  				writeTableForProperty is empty or your input is not exists. 				(" . $propertyName . ")", WindLogger::LEVEL_DEBUG, 'wind.core'); return false; } if ($this->_typeValidation && $_writeTableProperties[$propertyName]) { if ($value instanceof $_writeTableProperties[$propertyName]) return true; Wind::log( "[core.WindModule.validatePropertyName] 				type of the property " . $propertyName . " is not defined. 				", WindLogger::LEVEL_DEBUG, 'wind.core'); return false; } return true; } public function getConfig($configName = '', $subConfigName = '', $default = '') { if ($this->_config === null) { Wind::log('[core.WindModule.getConfig] config is not exist.', WindLogger::LEVEL_INFO, 'wind.core'); return $default; } return $this->_config->getConfig($configName, $subConfigName, array(), $default); } public function setConfig($config) { if (!$config) return; if (is_string($config)) { Wind::import('WIND:core.config.parser.WindConfigParser'); $config = new WindConfig($config, new WindConfigParser(), get_class($this), WIND_CONFIG_CACHE); } elseif (is_array($config)) $config = new WindConfig($config); if ($this->_config !== null) $this->_config->setConfig($config->getConfig(), true); else $this->_config = $config; } protected function writeTableForProperty() { return array('delayAttributes' => 'array'); } protected function writeTableCloneProperty() { return array(); } protected function getSystemConfig() { return Wind::getApp()->getWindSystemConfig(); } protected function getSystemFactory() { return Wind::getApp()->getWindFactory(); } protected function getRequest() { return Wind::getApp()->getRequest(); } protected function getResponse() { return Wind::getApp()->getResponse(); } public function setDelayAttributes($delayAttributes) { $this->delayAttributes = array_merge($this->delayAttributes, $delayAttributes); } }   class WindHandlerInterceptor extends WindModule { protected $result = null; protected $interceptorChain = null; public function preHandle() {} public function postHandle() {} public function handle() { $args = func_get_args(); $this->result = call_user_func_array(array($this, 'preHandle'), $args); if ($this->result !== null) { return $this->result; } if (null !== ($handler = $this->interceptorChain->getHandler())) { $this->result = call_user_func_array(array($handler, 'handle'), $args); } else { $this->result = $this->interceptorChain->execute(); } call_user_func_array(array($this, 'postHandle'), $args); return $this->result; } public function setHandlerInterceptorChain($interceptorChain) { $this->interceptorChain = $interceptorChain; } }    Wind::import('WIND:core.filter.WindHandlerInterceptor'); class WindFilter extends WindHandlerInterceptor { public function preHandle() { } public function postHandle() { } }   class WindHandlerInterceptorChain extends WindModule { protected $_interceptors = array(); protected $_callBack = null; protected $_args = array(); private $_state = true; public function setCallBack($callBack, $args = array()) { $this->_callBack = $callBack; $this->_args = $args; } public function execute() { if ($this->_callBack === null) return null; if (is_string($this->_callBack) && !function_exists($this->_callBack)) { throw new WindException('[core.filter.WindHandlerInterceptorChain.execute]' . $this->_callBack, WindException::ERROR_FUNCTION_NOT_EXIST); } return call_user_func_array($this->_callBack, (array) $this->_args); } public function getHandler() { if ($this->_state) { $this->addInterceptors(new WindHandlerInterceptor()); $this->_state = false; } if (count($this->_interceptors) <= 0) return null; $handler = array_shift($this->_interceptors); if ($handler instanceof WindHandlerInterceptor) { $handler->setHandlerInterceptorChain($this); return $handler; } Wind::log( '[core.filter.WindHandlerInterceptorChain.getHandler] the type of Interceptor ' . gettype($handler) . ' is not supported.', WindLogger::LEVEL_DEBUG, 'wind.core'); return $this->getHandler(); } public function addInterceptors($interceptors) { if (is_array($interceptors)) $this->_interceptors += $interceptors; else $this->_interceptors[] = $interceptors; } }    Wind::import('WIND:core.filter.WindHandlerInterceptorChain'); class WindFilterChain extends WindHandlerInterceptorChain { public function __construct($filterConfig) { $this->_initFilters($filterConfig); } public function deleteFilter($alias) { unset($this->_interceptors[$alias]); } public function addFilter($filter, $beforFilter = '') { if ($beforFilter === '') { $this->addInterceptors(array(get_class($filter) => $filter)); return true; } $_interceptors = array(); foreach ($this->_interceptors as $key => $interceptor) { if ($beforFilter === $key) break; $_interceptors[$key] = $interceptor; unset($this->_interceptors[$key]); } $_interceptors[get_class($filter)] = $filter; $this->_interceptors = (array) $_interceptors + (array) $this->_interceptors; } private function _initFilters($filters = array()) { $_temp = array(); foreach ((array) $filters as $key => $filter) { if (!is_array($filter)) continue; $filterClass = Wind::import($filter[WindSystemConfig::CLASS_PATH]); if (!class_exists($filterClass)) continue; $_temp[$key] = new $filterClass(); } $this->addInterceptors($_temp); } }   interface IWindRequest { const INPUT_TYPE_GET = 'get'; const INPUT_TYPE_POST = 'post'; const INPUT_TYPE_COOKIE = 'cookie'; }    class WindHttpRequest implements IWindRequest { private $_port = null; private $_clientIp = null; private $_language = null; private $_pathInfo = null; private $_scriptUrl = null; private $_requestUri = null; private $_baseUrl = null; private $_hostInfo = null; private $_attribute = array(); private $_response = null; public function __construct() { $this->normalizeRequest(); } protected function normalizeRequest() { if (function_exists('get_magic_quotes_gpc') && get_magic_quotes_gpc()) { if (isset($_GET)) $_GET = $this->stripSlashes($_GET); if (isset($_POST)) $_POST = $this->stripSlashes($_POST); if (isset($_REQUEST)) $_REQUEST = $this->stripSlashes($_REQUEST); if (isset($_COOKIE)) $_COOKIE = $this->stripSlashes($_COOKIE); } } public function stripSlashes(&$data) { return is_array($data) ? array_map(array($this, 'stripSlashes'), $data) : stripslashes($data); } public function setAttribute($data, $key = '') { if ($key) { $this->_attribute[$key] = $data; return; } if (is_object($data)) $data = get_object_vars($data); if (is_array($data)) $this->_attribute = array_merge($this->_attribute, $data); } public function getAttribute($key, $defaultValue = '') { if (isset($this->_attribute[$key])) return $this->_attribute[$key]; else if (isset($_GET[$key])) return $_GET[$key]; else if (isset($_POST[$key])) return $_POST[$key]; else if (isset($_COOKIE[$key])) return $_COOKIE[$key]; else if (isset($_REQUEST[$key])) return $_REQUEST[$key]; else if (isset($_ENV[$key])) return $_ENV[$key]; else if (isset($_SERVER[$key])) return $_SERVER[$key]; else return $defaultValue; } public function getRequest($key = null, $defaultValue = null) { if (!$key) return array_merge($_POST, $_GET); if (isset($_GET[$key])) return $_GET[$key]; if (isset($_POST[$key])) return $_POST[$key]; return $defaultValue; } public function getQuery($name = null, $defaultValue = null) { return $this->getGet($name, $defaultValue); } public function getPost($name = null, $defaultValue = null) { if ($name == null) return $_POST; return isset($_POST[$name]) ? $_POST[$name] : $defaultValue; } public function getGet($name = '', $defaultValue = null) { if ($name == null) return $_GET; return (isset($_GET[$name])) ? $_GET[$name] : $defaultValue; } public function getCookie($name = null, $defaultValue = null) { if ($name == null) return $_COOKIE; return (isset($_COOKIE[$name])) ? $_COOKIE[$name] : $defaultValue; } public function getSession($name = null, $defaultValue = null) { if ($name == null) return $_SESSION; return (isset($_SESSION[$name])) ? $_SESSION[$name] : $defaultValue; } public function getServer($name = null, $defaultValue = null) { if ($name == null) return $_SERVER; return (isset($_SERVER[$name])) ? $_SERVER[$name] : $defaultValue; } public function getEnv($name = null, $defaultValue = null) { if ($name == null) return $_ENV; return (isset($_ENV[$name])) ? $_ENV[$name] : $defaultValue; } public function getScheme() { return ($this->getServer('HTTPS') == 'on') ? 'https' : 'http'; } public function getProtocol() { return $this->getServer('SERVER_PROTOCOL', 'HTTP/1.0'); } public function getClientIp() { if (!$this->_clientIp) $this->_getClientIp(); return $this->_clientIp; } public function getRequestMethod() { return strtoupper($this->getServer('REQUEST_METHOD')); } public function getRequestType() { return IWindRequest::REQUEST_TYPE_WEB; } public function getIsAjaxRequest() { return !strcasecmp($this->getServer('HTTP_X_REQUESTED_WITH'), 'XMLHttpRequest'); } public function isSecure() { return !strcasecmp($this->getServer('HTTPS'), 'on'); } public function isGet() { return !strcasecmp($this->getRequestMethod(), 'GET'); } public function isPost() { return !strcasecmp($this->getRequestMethod(), 'POST'); } public function isPut() { return !strcasecmp($this->getRequestMethod(), 'PUT'); } public function isDelete() { return !strcasecmp($this->getRequestMethod(), 'Delete'); } public function getRequestUri() { if (!$this->_requestUri) $this->initRequestUri(); return $this->_requestUri; } public function getScriptUrl() { if (!$this->_scriptUrl) $this->_initScriptUrl(); return $this->_scriptUrl; } public function getScript() { if (($pos = strrpos($this->getScriptUrl(), '/')) === false) $pos = -1; return substr($this->getScriptUrl(), $pos + 1); } public function getHeader($header, $default = null) { $temp = strtoupper(str_replace('-', '_', $header)); if (substr($temp, 0, 5) != 'HTTP_') $temp = 'HTTP_' . $temp; if (($header = $this->getServer($temp)) != null) return $header; if (function_exists('apache_request_headers')) { $headers = apache_request_headers(); if ($headers[$header]) return $headers[$header]; } return $default; } public function getPathInfo() { if (!$this->_pathInfo) $this->_initPathInfo(); return $this->_pathInfo; } public function getBaseUrl($absolute = false) { if ($this->_baseUrl === null) $this->_baseUrl = rtrim(dirname($this->getScriptUrl()), '\\/.'); return $absolute ? $this->getHostInfo() . $this->_baseUrl : $this->_baseUrl; } public function getHostInfo() { if ($this->_hostInfo === null) $this->_initHostInfo(); return $this->_hostInfo; } public function getServerName() { return $this->getServer('SERVER_NAME', ''); } public function getServerPort() { if (!$this->_port) { $_default = $this->isSecure() ? 443 : 80; $this->setServerPort($this->getServer('SERVER_PORT', $_default)); } return $this->_port; } public function setServerPort($port) { $this->_port = (int) $port; } public function getRemoteHost() { return $this->getServer('REMOTE_HOST'); } public function getUrlReferer() { return $this->getServer('HTTP_REFERER'); } public function getRemotePort() { return $this->getServer('REMOTE_PORT'); } public function getUserAgent() { return $this->getServer('HTTP_USER_AGENT', ''); } public function getAcceptTypes() { return $this->getServer('HTTP_ACCEPT', ''); } public function getAcceptCharset() { return $this->getServer('HTTP_ACCEPT_ENCODING', ''); } public function getAcceptLanguage() { if (!$this->_language) { $_language = explode(',', $this->getServer('HTTP_ACCEPT_LANGUAGE', '')); $this->_language = $_language[0] ? $_language[0] : 'zh-cn'; } return $this->_language; } public function getResponse() { if ($this->_response === null) { Wind::import('WIND:core.response.WindHttpResponse'); $this->_response = new WindHttpResponse(); if ($this->getIsAjaxRequest()) { $this->_response->addHeader('Content-type', 'text/xml;charset=utf-8'); $this->_response->setIsAjax(true); } else $this->_response->addHeader('Content-type', 'text/html;charset=utf-8'); } return $this->_response; } private function _getClientIp() { if (($ip = $this->getServer('HTTP_CLIENT_IP')) != null) { $this->_clientIp = $ip; } elseif (($_ip = $this->getServer('HTTP_X_FORWARDED_FOR')) != null) { $ip = strtok($_ip, ','); do { $ip = ip2long($ip); if (!(($ip == 0) || ($ip == 0xFFFFFFFF) || ($ip == 0x7F000001) || (($ip >= 0x0A000000) && ($ip <= 0x0AFFFFFF)) || (($ip >= 0xC0A8FFFF) && ($ip <= 0xC0A80000)) || (($ip >= 0xAC1FFFFF) && ($ip <= 0xAC100000)))) { $this->_clientIp = long2ip($ip); return; } } while (($ip = strtok(','))); } elseif (($ip = $this->getServer('HTTP_PROXY_USER')) != null) { $this->_clientIp = $ip; } elseif (($ip = $this->getServer('REMOTE_ADDR')) != null) { $this->_clientIp = $ip; } else { $this->_clientIp = "0.0.0.0"; } } private function initRequestUri() { if (($requestUri = $this->getServer('HTTP_X_REWRITE_URL')) != null) { $this->_requestUri = $requestUri; } elseif (($requestUri = $this->getServer('REQUEST_URI')) != null) { $this->_requestUri = $requestUri; if (strpos($this->_requestUri, $this->getServer('HTTP_HOST')) !== false) $this->_requestUri = preg_replace( '/^\w+:\/\/[^\/]+/', '', $this->_requestUri); } elseif (($requestUri = $this->getServer('ORIG_PATH_INFO')) != null) { $this->_requestUri = $requestUri; if (($query = $this->getServer('QUERY_STRING')) != null) $this->_requestUri .= '?' . $query; } else throw new WindException(__CLASS__ . ' is unable to determine the request URI.'); } private function _initScriptUrl() { if (($scriptName = $this->getServer('SCRIPT_FILENAME')) == null) throw new WindException( __CLASS__ . ' determine the entry script URL failed!!!'); $scriptName = basename($scriptName); if (($_scriptName = $this->getServer('SCRIPT_NAME')) != null && basename($_scriptName) === $scriptName) { $this->_scriptUrl = $_scriptName; } elseif (($_scriptName = $this->getServer('PHP_SELF')) != null && basename($_scriptName) === $scriptName) { $this->_scriptUrl = $_scriptName; } elseif (($_scriptName = $this->getServer('ORIG_SCRIPT_NAME')) != null && basename($_scriptName) === $scriptName) { $this->_scriptUrl = $_scriptName; } elseif (($pos = strpos($this->getServer('PHP_SELF'), '/' . $scriptName)) !== false) { $this->_scriptUrl = substr($this->getServer('SCRIPT_NAME'), 0, $pos) . '/' . $scriptName; } elseif (($_documentRoot = $this->getServer('DOCUMENT_ROOT')) != null && ($_scriptName = $this->getServer('SCRIPT_FILENAME')) != null && strpos($_scriptName, $_documentRoot) === 0) { $this->_scriptUrl = str_replace('\\', '/', str_replace($_documentRoot, '', $_scriptName)); } else throw new WindException(__CLASS__ . ' determine the entry script URL failed!!'); } private function _initHostInfo() { $http = $this->isSecure() ? 'https' : 'http'; if (($httpHost = $this->getServer('HTTP_HOST')) != null) $this->_hostInfo = $http . '://' . $httpHost; elseif (($httpHost = $this->getServer('SERVER_NAME')) != null) { $this->_hostInfo = $http . '://' . $httpHost; if (($port = $this->getServerPort()) != null) $this->_hostInfo .= ':' . $port; } else throw new WindException(__CLASS__ . ' determine the entry script URL failed!!'); } private function _initPathInfo() { $requestUri = urldecode($this->getRequestUri()); $scriptUrl = $this->getScriptUrl(); $baseUrl = $this->getBaseUrl(); if (strpos($requestUri, $scriptUrl) === 0) $pathInfo = substr($requestUri, strlen($scriptUrl)); elseif ($baseUrl === '' || strpos($requestUri, $baseUrl) === 0) $pathInfo = substr($requestUri, strlen($baseUrl)); elseif (strpos($_SERVER['PHP_SELF'], $scriptUrl) === 0) $pathInfo = substr($_SERVER['PHP_SELF'], strlen($scriptUrl)); else throw new WindException(''); if (($pos = strpos($pathInfo, '?')) !== false) $pathInfo = substr($pathInfo, 0, $pos); $this->_pathInfo = trim($pathInfo, '/'); } }   interface IWindResponse { }   Wind::import('WIND:core.response.IWindResponse'); class WindHttpResponse implements IWindResponse { private $_body = array(); private $_bodyIndex = array(); private $_headers = array(); private $_isRedirect = false; private $_status = ''; private $_isAjax = false; private $_data = array(); const SC_CONTINUE = 100; const SC_SWITCHING_PROTOCOLS = 101; const SC_OK = 200; const SC_CREATED = 201; const SC_ACCEPTED = 202; const SC_NON_AUTHORITATIVE_INFORMATION = 203; const SC_NO_CONTENT = 204; const SC_RESET_CONTENT = 205; const SC_PARTIAL_CONTENT = 206; const SC_MULTIPLE_CHOICES = 300; const SC_MOVED_PERMANENTLY = 301; const SC_MOVED_TEMPORARILY = 302; const SC_FOUND = 302; const SC_SEE_OTHER = 303; const SC_NOT_MODIFIED = 304; const SC_USE_PROXY = 305; const SC_TEMPORARY_REDIRECT = 307; const SC_BAD_REQUEST = 400; const SC_UNAUTHORIZED = 401; const SC_PAYMENT_REQUIRED = 402; const SC_FORBIDDEN = 403; const SC_NOT_FOUND = 404; const SC_METHOD_NOT_ALLOWED = 405; const SC_NOT_ACCEPTABLE = 406; const SC_PROXY_AUTHENTICATION_REQUIRED = 407; const SC_REQUEST_TIMEOUT = 408; const SC_CONFLICT = 409; const SC_GONE = 410; const SC_LENGTH_REQUIRED = 411; const SC_PRECONDITION_FAILED = 412; const SC_REQUEST_ENTITY_TOO_LARGE = 413; const SC_REQUEST_URI_TOO_LONG = 414; const SC_UNSUPPORTED_MEDIA_TYPE = 415; const SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416; const SC_EXPECTATION_FAILED = 417; const SC_INTERNAL_SERVER_ERROR = 500; const SC_NOT_IMPLEMENTED = 501; const SC_BAD_GATEWAY = 502; const SC_SERVICE_UNAVAILABLE = 503; const SC_GATEWAY_TIMEOUT = 504; const SC_HTTP_VERSION_NOT_SUPPORTED = 505; public function setHeader($name, $value, $replace = false) { if (trim($name) == '' || trim($value) == '') return; $name = $this->_normalizeHeader($name); foreach ($this->_headers as $key => $one) { ($one['name'] == $name) && $this->_headers[$key] = array('name' => $name, 'value' => $value, 'replace' => $replace); } } public function addHeader($name, $value, $replace = false) { if (trim($name) == '' || trim($value) == '') return; $name = $this->_normalizeHeader($name); $this->_headers[] = array('name' => $name, 'value' => $value, 'replace' => $replace); } public function setStatus($status, $message = '') { if (!is_int($status) || $status < 100 || $status > 505) return; $this->_status = (int) $status; } public function setBody($content, $name = null) { if (!$content) return; !$name && $name = 'default'; array_unshift($this->_bodyIndex, $name); $this->_body[$name] = $content; } public function addCookie(Cookie $cookie) { } public function sendError($status = self::SC_NOT_FOUND, $message = '') { if (!is_int($status) || $status < 400 || $status > 505) return; $this->setBody($message); $this->setStatus($status); } public function sendRedirect($location, $status = 302) { if (!is_int($status) || $status < 300 || $status > 399) return; $this->addHeader('Location', $location, true); $this->setStatus($status); $this->_isRedirect = true; $this->sendHeaders(); exit(); } public function sendResponse() { $this->sendHeaders(); $this->sendBody(); } public function sendHeaders() { if ($this->isSendedHeader()) return; foreach ($this->_headers as $header) { header($header['name'] . ': ' . $header['value'], $header['replace']); } header('HTTP/1.1 ' . $this->_status); } public function sendBody() { foreach ($this->_bodyIndex as $key) echo $this->_body[$key]; } public function getBody($name = false) { if ($name === false) { ob_start(); $this->sendBody(); return ob_get_clean(); } elseif ($name === true) { return $this->_body; } elseif (is_string($name) && isset($this->_body[$name])) return $this->_body[$name]; return null; } public function isSendedHeader($throw = false) { $sended = headers_sent($file, $line); if ($throw && $sended) throw new WindException( __CLASS__ . ' the headers are sent in file ' . $file . ' on line ' . $line); return $sended; } public function getHeaders() { return $this->_headers; } public function clearBody() { $this->_body = array(); } public function clearHeaders() { $this->_headers = array(); } private function _normalizeHeader($name) { if (trim($name) == '') return ''; $filtered = str_replace(array('-', '_'), ' ', (string) $name); $filtered = ucwords(strtolower($filtered)); $filtered = str_replace(' ', '-', $filtered); return $filtered; } public function getIsAjax() { return $this->_isAjax; } public function setIsAjax($_isAjax) { $this->_isAjax = $_isAjax; } public function getData($key1 = '', $key2 = '') { if (!$key1) return $this->_data; if (!$key2) return isset($this->_data[$key1]) ? $this->_data[$key1] : ''; return isset($this->_data[$key1]) ? (isset($this->_data[$key1][$key2]) ? $this->_data[$key1][$key2] : '') : ''; } public function setData($data, $key = '') { if ($key) { $this->_data[$key] = $data; return; } if (is_object($data)) $data = get_object_vars($data); if (is_array($data)) $this->_data += $data; } }   abstract class AbstractWindRouter extends WindModule { const DEFAULT_ERROR_HANDLER = 'WIND:core.web.WindErrorHandler'; const CONTROLLER_DEFAULT_PATH = 'controller'; const CONTROLLER_DEFAULT_SUFFIX = 'Controller'; private $action = 'run'; private $controller = 'index'; private $module = 'default'; protected $modulePath = ''; private $reParse = true; abstract public function parse(); abstract public function buildUrl(); public function doParse() { $_moduleName = $this->getModule(); if (!strcasecmp($this->getController(), WIND_M_ERROR)) { if (IS_DEBUG && IS_DEBUG <= WindLogger::LEVEL_DEBUG) { Wind::log( '[core.roter.AbstractWindRouter.doParse] action hander: default error action :' . self::DEFAULT_ERROR_HANDLER, WindLogger::LEVEL_DEBUG, 'wind.core'); } return $this->getSystemConfig()->getModuleErrorHandlerByModuleName($_moduleName, self::DEFAULT_ERROR_HANDLER); } if ($this->reParse) { $this->parse(); $this->reParse = false; Wind::log('[core.router.AbstractWindRouter.doParse] parse the request.', WindLogger::LEVEL_DEBUG, 'wind.core'); } $_suffix = $this->getSystemConfig()->getModuleControllerSuffixByModuleName($_moduleName, self::CONTROLLER_DEFAULT_SUFFIX); if ($this->modulePath) $_path = $this->modulePath; else { $_path = $this->getSystemConfig()->getModuleControllerPathByModuleName($_moduleName, self::CONTROLLER_DEFAULT_PATH); } $_path .= '.' . ucfirst($this->controller) . $_suffix; if (IS_DEBUG && IS_DEBUG <= WindLogger::LEVEL_DEBUG) { Wind::log('[core.router.AbstractWindRouter.doParse] action handler: ' . $_path, WindLogger::LEVEL_DEBUG, 'wind.core'); } $this->destroy(); return $_path; } protected function destroy() { $this->modulePath = ''; } public function setModule($module) { if (false !== ($pos = strpos($module, ':'))) { $this->modulePath = $module; } else { $this->module = $module; $this->modulePath = ''; } } public function getAction() { return $this->action; } public function getController() { return $this->controller; } public function getModule() { return $this->module; } public function setAction($action) { $this->action = $action; } public function setController($controller) { $this->controller = $controller; } public function reParse() { $this->reParse = true; } }   class WindUrlBasedRouter extends AbstractWindRouter { const URL_PARAM = 'url-param'; const DEFAULT_VALUE = 'default-value'; const CONTROLLER_SUFFIX = 'controller-suffix'; const ACTION_SUFFIX = 'action-suffix'; const URL_RULE_MODULE = 'module'; const URL_RULE_CONTROLLER = 'controller'; const URL_RULE_ACTION = 'action'; public function parse() { $this->setModule($this->getUrlParamValue(self::URL_RULE_MODULE, $this->getModule())); $this->setController($this->getUrlParamValue(self::URL_RULE_CONTROLLER, $this->getController())); $this->setAction($this->getUrlParamValue(self::URL_RULE_ACTION, $this->getAction())); } public function buildUrl() { $module = $this->getUrlParamValue(self::URL_RULE_MODULE); $controller = $this->getUrlParamValue(self::URL_RULE_CONTROLLER); $action = $this->getUrlParamValue(self::URL_RULE_ACTION); $url = '?' . $module . '=' . $this->getModule(); $url .= '&' . $controller . '=' . $this->getController(); $url .= '&' . $action . '=' . $this->getAction(); return $url; } private function getUrlParamValue($type, $defaultValue = '') { if ($_param = $this->getConfig($type, self::URL_PARAM)) { $_defaultValue = $this->getConfig($type, self::DEFAULT_VALUE, $defaultValue); return $this->getRequest()->getRequest($_param, $defaultValue); } return $defaultValue; } }   interface IWindController { public function doAction($handlerAdapter); public function preAction($handlerAdapter); public function postAction($handlerAdapter); }    abstract class WindSimpleController extends WindModule implements IWindController { protected $forward = null; protected $urlHelper = null; protected $errorMessage = null; abstract public function run(); protected function beforeAction($handlerAdapter) {} protected function afterAction($handlerAdapter) {} public function preAction($handlerAdapter) { $this->urlHelper = null; $this->errorMessage = null; $this->forward = null; } public function postAction($handlerAdapter) {} public function doAction($handlerAdapter) { $this->beforeAction($handlerAdapter); $this->setDefaultTemplateName($handlerAdapter); $method = $this->resolvedActionMethod($handlerAdapter); Wind::log('[core.web.controller.WindSimpleController.doAction] resolved action method:' . $method, WindLogger::LEVEL_INFO, 'wind.core'); call_user_func_array(array($this, $method), array()); $this->getErrorMessage()->sendError(); $this->afterAction($handlerAdapter); return $this->forward; } protected function forwardAction($action = 'run', $controller = '', $args = array(), $isRedirect = false) { $this->getForward()->forwardAnotherAction($action, $controller, $args, $isRedirect); } protected function forwardRedirect($url) { $this->getForward()->setIsRedirect(true); $this->getForward()->setUrl($url); } protected function setOutput($data, $key = '') { $this->getForward()->setVars($data, $key); } protected function getInput($name, $type = '', $callback = null) { if (is_array($name)) return $this->getInputWithArray($name, $type); else return $this->getInputWithString($name, $type, $callback); } protected function setTemplate($template) { $this->getForward()->setTemplateName($template); } protected function setTemplatePath($templatePath) { $this->getForward()->setTemplatePath($templatePath); } protected function setTemplateExt($templateExt) { $this->getForward()->setTemplateExt($templateExt); } protected function setLayout($layout) { $this->getForward()->setLayout($layout); } protected function addMessage($message, $key = '') { $this->getErrorMessage()->addError($message, $key); } protected function showMessage($message = '', $key = '', $errorAction = '', $errorController = '') { $this->addMessage($message, $key); $this->getErrorMessage()->setErrorAction($errorAction); $this->getErrorMessage()->setErrorController($errorController); $this->getErrorMessage()->sendError(); } protected function setDefaultTemplateName($handlerAdapter) {} protected function resolvedActionMethod($handlerAdapter) { return 'run'; } private function getInputWithString($name, $type = '', $callback = array()) { $value = ''; switch (strtolower($type)) { case 'form': $value = $this->response->getData($name); break; case IWindRequest::INPUT_TYPE_GET: $value = $this->request->getGet($name); break; case IWindRequest::INPUT_TYPE_POST: $value = $this->request->getPost($name); break; case IWindRequest::INPUT_TYPE_COOKIE: $value = $this->request->getCookie($name); break; default: $value = $this->request->getAttribute($name); } return $callback ? array($value, call_user_func_array($callback, array($value))) : $value; } private function getInputWithArray($name, $type = '') { $result = array(); foreach ($name as $key => $value) { $result[(is_array($value) ? $key : $value)] = $this->getInput($value, $type); } return $result; } protected function getForward() { return $this->_getForward(); } protected function getUrlHelper() { return $this->_getUrlHelper(); } protected function getErrorMessage() { return $this->_getErrorMessage(); } }    class WindController extends WindSimpleController { protected $validatorClass = 'WIND:component.utility.WindValidator'; protected $formClass = ''; public function run() {} final public function preAction($handlerAdapter) { parent::preAction($handlerAdapter); if ($formClassPath = $this->getFormClass()) { $this->registerEventListener('doAction', new WindFormListener($this->request, $formClassPath, $this->getErrorMessage())); } elseif ($rules = $this->validatorFormRule($handlerAdapter->getAction())) { if (!isset($rules['errorMessage'])) { $rules['errorMessage'] = $this->getErrorMessage(); } $this->registerEventListener('doAction', new WindValidateListener($this->request, $rules, $this->getValidatorClass())); } } protected function setDefaultTemplateName($handlerAdapter) { $_temp = $handlerAdapter->getController() . '_' . $handlerAdapter->getAction(); $this->setTemplate($_temp); } protected function resolvedActionMethod($handlerAdapter) { $action = $handlerAdapter->getAction(); if ($action !== 'run') $action = $this->resolvedActionName($action); try { if ($action == 'doAction') throw new WindException('[core.web.WindController.resolvedActionMethod]', WindException::ERROR_CLASS_METHOD_NOT_EXIST); $method = new ReflectionMethod($this, $action); if ($method->isAbstract() || !$method->isPublic()) throw new WindException( '[core.web.WindController.resolvedActionMethod]', WindException::ERROR_CLASS_METHOD_NOT_EXIST); return $action; } catch (Exception $exception) { throw new WindException( '[core.web.WindController.resolvedActionMethod] action method:' . $action . ' exception message:' . $exception->getMessage()); } } protected function resolvedActionName($action) { return $action . 'Action'; } protected function validatorFormRule($type) { return array(); } protected function getFormClass() { return $this->formClass; } protected function getValidatorClass() { return $this->validatorClass; } }   Wind::import('WIND:core.filter.WindFilter'); class WindLoggerFilter extends WindFilter { public function preHandle($request = null, $response = null) { if (!IS_DEBUG) return; $this->initWindLogger($request); $this->logger->info('-------------------------------request start!!!!--------------------------------'); } public function postHandle($request = null, $response = null) { if (!IS_DEBUG) return; $this->logger->info('---------------------------------request end!!!!---------------------------------'); if ($this->logger instanceof WindLogger) $this->logger->flush(); } private function initWindLogger($request) { $windFactory = $request->getAttribute(WindFrontController::WIND_FACTORY); $this->logger = $windFactory->getInstance(COMPONENT_LOGGER); } }    Wind::import('WIND:core.filter.WindFilter'); class WindUrlFilter extends WindFilter { public function preHandle($request = null, $response = null) { $windFactory = $request->getAttribute(WindFrontController::WIND_FACTORY); $this->urlHelper = $windFactory->getInstance(COMPONENT_URLHELPER); $this->urlHelper->parseUrl(); } public function postHandle($request = null, $response = null) { } }    interface IWindApplication { public function processRequest(); public function doDispatch($forward); }    interface IWindErrorMessage { public function addError($message, $key = ''); public function getError($key = ''); public function clearError(); public function sendError(); }    Wind::import('WIND:core.filter.WindHandlerInterceptor'); class WindFormListener extends WindHandlerInterceptor { private $request = null; private $formPath = ''; private $errorMessage = null; public function __construct($request, $formPath, $errorMessage) { $this->request = $request; $this->formPath = $formPath; $this->errorMessage = $errorMessage; } public function preHandle() { $className = Wind::import($this->formPath); if (!class_exists($className)) throw new WindException('the form \'' . $this->formPath . '\' is not exists!'); if ('WindEnableValidateModule' != get_parent_class($className)) throw new WindException('the form \'' . $this->formPath . '\' is not extends \'WindEnableValidateModule\'!'); $form = new $className(); $methods = get_class_methods($form); foreach ($methods as $method) { if ((0 !== strpos($method, 'set')) || ('' == ($_tmp = substr($method, 3)))) continue; $_tmp[0] = strtolower($_tmp[0]); $value = $this->request->getPost($_tmp) ? $this->request->getPost($_tmp) : $this->request->getGet($_tmp); if (null === $value) continue; call_user_func_array(array($form, $method), array($value)); } call_user_func_array(array($form, 'validate'), array($form)); if (($error = $form->getErrors())) { list($errorController, $errorAction) = $form->getErrorControllerAndAction(); $this->sendError($errorController, $errorAction, $error); } $this->request->setAttribute('formData', $form); } private function sendError($errorController, $errorAction, $errors) { if (!$this->errorMessage instanceof WindErrorMessage) $this->errorMessage = new WindErrorMessage(); $this->errorMessage->setErrorController($errorController); $this->errorMessage->setErrorAction($errorAction); $this->errorMessage->addError($errors); $this->errorMessage->sendError(); } public function postHandle() { } }    Wind::import('WIND:core.filter.WindHandlerInterceptor'); Wind::import('WIND:component.log.WindLogger'); class WindLoggerListener extends WindHandlerInterceptor { public function __construct($request) { $this->request = $request; } public function preHandle() { $logger = $this->getLogger(); if ($logger instanceof WindLogger) { $logger->info($this->getPreLogMessage(func_get_args())); } } public function postHandle() { $logger = $this->getLogger(); if ($logger instanceof WindLogger) { $logger->info($this->getPostLogMessage(func_get_args())); } } private function getLogger() { if (!isset($this->logger)) { $factory = $this->request->getAttribute(WindFrontController::WIND_FACTORY); $this->logger = $factory->getInstance(COMPONENT_LOGGER); } return $this->logger; } private function getPreLogMessage($args) { $log = $this->getLogMessage($args); $log['caller'] = ' #[caller]: ' . $log['caller']; $log['excute'] = ' #[excute-begin]: ' . $log['excute']; $message = 'Begin ' . $this->event[0] . '->' . $this->event[1]; return "{$message}<br/>" . implode("\r\n", $log) . '<br/>'; } private function getPostLogMessage($args) { $log = $this->getLogMessage($args); $log['caller'] = ' #[caller]: ' . $log['caller']; $log['excute'] = ' #[excute-end]: ' . $log['excute']; $log['output'] = ' #[output]: ' . $this->buildArg($this->result); $message = 'End ' . $this->event[0] . '->' . $this->event[1]; return "{$message}<br/>" . implode("\r\n", $log) . '<br/>'; } private function getLogMessage($args) { $method = ''; $info = array(); $flag = false; foreach (debug_backtrace(false) as $traceKey => $trace) { $class = isset($trace['class']) ? $trace['class'] : ''; if (in_array($class, array('', 'WindLogger', __CLASS__, 'WindHandlerInterceptor'))) continue; $function = isset($trace['function']) ? $trace['function'] : ''; ($class == 'WindClassProxy' && $function == '__call') && $method = trim($trace['args'][0]); ($function == $method) && $flag = true; if (!isset($trace['file'])) continue; $info['caller'] = addslashes($trace['file']) . '(' . $trace['line'] . '): '; break; } list($class, $method) = $this->event; $args = array_map(array($this, 'buildArg'), $args); $info['excute'] = $class . '->' . $method . '(' . implode(', ', $args) . ')'; return $info; } private function buildArg($arg) { switch (gettype($arg)) { case 'array': return 'Array'; break; case 'object': return 'Object ' . get_class($arg); break; default: return "'" . $arg . "'"; break; } } }    Wind::import('WIND:core.filter.WindHandlerInterceptor'); class WindValidateListener extends WindHandlerInterceptor { private $request = null; private $validateRules = array(); private $validator = null; private $validatorClass = ''; private $defaultMessage = ''; public function __construct($request, $validateRules, $validatorClass) { $this->request = $request; $this->validateRules = (array) $validateRules; $this->validatorClass = $validatorClass; } public function preHandle() { if (!isset($this->validateRules['errorMessage'])) $errorMessage = new WindErrorMessage(); else { $errorMessage = $this->validateRules['errorMessage']; unset($this->validateRules['errorMessage']); } $_input = new stdClass(); foreach ((array) $this->validateRules as $rule) { if (!is_array($rule)) continue; $key = $rule['field']; $value = $this->request->getGet($key) ? $this->request->getGet($key) : $this->request->getPost($key); $args = $rule['args']; array_unshift($args, $value); if (call_user_func_array(array($this->getValidator(), $rule['validator']), (array) $args) === false) { if (null === $rule['default']) $errorMessage->addError(($rule['message'] ? $rule['message'] : $this->defaultMessage), $key); else $value = $rule['default']; } $this->request->setAttribute($key, $value); $_input->$key = $value; } if ($errorMessage->getError()) $errorMessage->sendError(); else $this->request->setAttribute('inputData', $_input); } private function getValidator() { if ($this->validator === null) { $_className = Wind::import($this->validatorClass); Wind::import('WIND:core.factory.WindFactory'); $this->validator = WindFactory::createInstance($_className); if ($this->validator === null) throw new WindException('validator', WindException::ERROR_RETURN_TYPE_ERROR); } return $this->validator; } public function postHandle() { } }   Wind::import('COM:viewer.exception.WindViewException'); class WindDispatcher extends WindModule { protected $processCache = array(); protected $urlHelper = null; protected $display = false; public function dispatch($app, $forward, $router) { $this->checkProcess($router, false); if ($forward->getIsRedirect()) $this->dispatchWithRedirect($app, $forward, $router); elseif ($forward->getIsReAction()) $this->dispatchWithAction($app, $forward, $router); else $this->render($app, $forward, $router); $this->destroy(); } protected function dispatchWithRedirect($app, $forward, $router) { $_url = $forward->getUrl(); if (!$_url && $forward->getIsReAction()) { $_url = $this->getUrlHelper()->createUrl($forward->getAction(), $forward->getController(), $forward->getArgs()); $router->reParse(); if (!$this->checkProcess($router)) { throw new WindException('[core.web.WindDispatcher.dispatchWithRedirect] Duplicate request ', WindException::ERROR_SYSTEM_ERROR); } } else $_url = $this->getUrlHelper()->checkUrl($_url); $this->getResponse()->sendRedirect($_url); } protected function dispatchWithAction($app, $forward, $router) { $this->getRequest()->setAttribute($forward->getVars(), $router->getAction() . '_' . $router->getController()); $this->setDisplay($forward->getDisplay()); list($_c, $_m) = WindHelper::resolveController($forward->getController()); $_a = $forward->getAction(); $_a && $router->setAction($_a); $_c && $router->setController($_c); $_m && $router->setModule($_m); if (!$this->checkProcess($router)) { throw new WindException('[core.web.WindDispatcher.dispatchWithAction] Duplicate request ', WindException::ERROR_SYSTEM_ERROR); } $app->processRequest(); } protected function render($app, $forward, $router) { try { if ($windViewClass = $forward->getWindView()) $view = $this->getSystemFactory()->createInstance($windViewClass); elseif ($windViewClass = $this->getSystemConfig()->getModuleViewClassByModuleName($router->getModule())) $view = $this->getSystemFactory()->getInstance($windViewClass); else $view = $this->getSystemFactory()->getInstance(COMPONENT_VIEW); $view->setConfig($this->getSystemConfig()->getModuleViewConfigByModuleName($router->getModule())); $view->render($forward, $router, $this->getDisplay()); } catch (Exception $e) { throw new WindViewException('[core.web.WindDispatcher.render] view render fail.' . $e->getMessage()); } } protected function checkProcess($router, $check = true) { if ($check === false) { $this->processCache['action'] = $router->getAction(); $this->processCache['controller'] = $router->getController(); $this->processCache['module'] = $router->getModule(); } elseif ($router->getAction() === $this->processCache['action'] && $router->getController() === $this->processCache['controller'] && $router->getModule() === $this->processCache['module']) return false; return true; } protected function destroy() { $this->processCache = array(); $this->setDisplay(false); } public function getDisplay() { return $this->display; } public function setDisplay($display) { $this->display = $display; } public function getUrlHelper() { return $this->_getUrlHelper(); } public function setUrlHelper($urlHelper) { $this->urlHelper = $urlHelper; } }    class WindErrorHandler extends WindController { protected $error = array(); protected $urlReferer = ''; public function beforeAction($handlerAdapter) { $this->error = $this->getInput('error'); if ($this->request->getUrlReferer()) $this->urlReferer = $this->request->getUrlReferer(); else $this->urlReferer = $this->request->getBaseUrl(); return true; } public function run() { $_tmp = "User Message:\r\n"; $i = 0; foreach ($this->error as $key => $value) { $i++; $_tmp .= "#$i " . $value . "\r\n"; } echo "<h3>User Message: (" . count($this->error) . ")</h3>"; echo "<p>" . nl2br($_tmp) . "</p>"; echo "<a href='" . $this->urlReferer . "'>Click to go back.</a>"; Wind::log('User Error:', $_tmp); exit(); } final public function errorHandle($errno, $errstr, $errfile, $errline) { if ($errno & error_reporting()) { $errfile = $this->getFile($errfile); $_tmp = "$errstr ($errfile:$errline)\r\nStack trace:\r\n"; $_trace = debug_backtrace(); foreach ($_trace as $key => $value) { if (!isset($value['file'])) continue; if (!isset($value['line'])) $value['line'] = 0; if (!isset($value['function'])) continue; $_tmp .= "#$key {$value['file']}({$value['line']}): "; if (isset($value['object']) && is_object($value['object'])) $_tmp .= get_class($value['object']) . '->'; $_tmp .= "{$value['function']}()\r\n"; } if (IS_DEBUG) { echo "<h3>" . $this->errnoMap($errno) . " $errstr</h3>"; echo "<p>" . nl2br($_tmp) . "</p>"; } else echo "<h3>" . $this->errnoMap($errno) . " $errstr</h3>"; Wind::log($this->errnoMap($errno) . $errstr, $_tmp); exit(); } } private function errnoMap($errno) { $_tmp = ''; switch ($errno) { case E_ERROR: $_tmp = "Error"; break; case E_WARNING: $_tmp = "Warning"; break; case E_PARSE: $_tmp = "Parse Error"; break; case E_NOTICE: $_tmp = "Notice"; break; case E_CORE_ERROR: $_tmp = "Core Error"; break; case E_CORE_WARNING: $_tmp = "Core Warning"; break; case E_COMPILE_ERROR: $_tmp = "Compile Error"; break; case E_COMPILE_WARNING: $_tmp = "Compile Warning"; break; case E_USER_ERROR: $_tmp = "User Error"; break; case E_USER_WARNING: $_tmp = "User Warning"; break; case E_USER_NOTICE: $_tmp = "User Notice"; break; case E_STRICT: $_tmp = "Strict Notice"; break; case E_RECOVERABLE_ERROR: $_tmp = "Recoverable Error"; break; default: $_tmp = "Unknown error ($errno)"; break; } return $_tmp; } final public function exceptionHandle($exception) { $_tmp = $exception->getMessage() . ' (' . $this->getFile($exception->getFile()) . ':' . $exception->getLine() . ')'; if (IS_DEBUG) { echo '<h3>' . get_class($exception) . '</h3>'; echo "<p>$_tmp</p>"; echo '<pre>' . $exception->getTraceAsString() . '</pre>'; } else { echo '<h3>' . get_class($exception) . '</h3>'; echo '<p>' . $exception->getMessage() . '</p>'; } Wind::log("$_tmp:" . $exception->getTraceAsString()); exit(); } private function getFile($filePath) { return $filePath; } }   class WindErrorMessage extends WindModule implements IWindErrorMessage { private $error = array(); private $errorAction = 'run'; private $errorController = WIND_M_ERROR; public function __construct($message = '', $errorAction = '', $errorController = '') { $this->addError($message); $this->setErrorAction($errorAction); $this->setErrorController($errorController); } public function sendError() { if (empty($this->error)) return; throw new WindActionException($this); } public function clearError() { $this->error = array(); } public function getError($key = '') { if ($key === '') return $this->error; else return isset($this->error[$key]) ? $this->error[$key] : ''; } public function addError($error, $key = '') { if (!$error) return; if ($key === '') { if (is_string($error)) $this->error[] = $error; elseif (is_object($error)) $error = get_object_vars($error); if (is_array($error)) $this->error += $error; } else $this->error[$key] = $error; } public function getErrorAction() { return $this->errorAction; } public function getErrorController() { return $this->errorController; } public function setErrorAction($errorAction) { if ($errorAction) $this->errorAction = $errorAction; } public function setErrorController($errorController) { if ($errorController) $this->errorController = $errorController; } }   class WindForward extends WindModule { private $windView; private $templateName; private $templatePath; private $templateExt; private $layout; private $vars = array(); private $isReAction = false; private $isRedirect = false; private $url; private $action; private $controller; private $args; private $display = false; public function forwardAnotherAction($action = 'run', $controller = '', $args = array(), $isRedirect = false) { $this->setIsReAction(true); $this->setAction($action); $this->setController($controller); $this->setArgs($args); $this->setIsRedirect($isRedirect); } public function setVars($vars, $key = '') { if (!$key) { if (is_object($vars)) $vars = get_object_vars($vars); if (is_array($vars)) $this->vars += $vars; } else $this->vars[$key] = $vars; return; } public function getIsRedirect() { return $this->isRedirect; } public function setIsRedirect($isRedirect) { $this->isRedirect = $isRedirect; } public function getIsReAction() { return $this->isReAction; } public function setIsReAction($isReAction) { $this->isReAction = $isReAction; } public function getVars() { return $this->vars; } public function getUrl() { return $this->url; } public function setUrl($url) { $this->url = $url; } public function getAction() { return $this->action; } public function getController() { return $this->controller; } public function getArgs() { return $this->args; } public function setAction($action) { $this->action = $action; } public function setController($controller) { $this->controller = $controller; } public function setArgs($args) { $this->args = $args; } public function getTemplateName() { return $this->templateName; } public function getTemplatePath() { return $this->templatePath; } public function getTemplateExt() { return $this->templateExt; } public function getLayout() { return $this->layout; } public function setTemplateName($templateName) { $this->templateName = $templateName; } public function setTemplatePath($templatePath) { $this->templatePath = $templatePath; } public function setTemplateExt($templateExt) { $this->templateExt = $templateExt; } public function setLayout($layout) { $this->layout = $layout; } public function getWindView() { return $this->windView; } public function setWindView($windView) { $this->windView = $windView; } public function getDisplay() { return $this->display; } public function setDisplay($display) { $this->display = $display; } }   class WindFrontController { const WIND_SYSTEM_CONFIG = 'WIND:core.config.WindSystemConfig'; const WIND_SYSTEM_FACTORY = 'WIND:core.factory.WindFactory'; const WIND_COMPONENT_CONFIG_RESOURCE = 'WIND:components_config.php'; private $request; private $response; protected $windSystemConfig = null; protected $windFactory = null; public function __construct($appName, $config = '') { try { $this->request = new WindHttpRequest(); $this->response = $this->request->getResponse(); $this->initWindConfig($appName, $config); $this->initWindFactory(); } catch (Exception $exception) { throw new Exception('System failed to initialize.' . $exception->getMessage()); } } public function run() { $this->beforeProcess(); $appName = $this->windSystemConfig->getAppClass(); $application = $this->windFactory->getInstance($appName); if ($application === null) { throw new WindException($appName . '[core.web.WindFrontController.process]', WindException::ERROR_CLASS_NOT_EXIST); } $routerAlias = $this->windSystemConfig->getRouterClass(); $application->setDelayAttributes(array('handlerAdapter' => array('ref' => $routerAlias))); if (null !== ($filterChain = $this->getFilterChain())) { $filterChain->setCallBack(array($application, 'processRequest'), array()); $filterChain->getHandler()->handle($this->request, $this->response); } else $application->processRequest($this->request, $this->response); $this->afterProcess(); } protected function getFilterChain() { $filterChainPath = $this->windSystemConfig->getFilterClass(); $filters = $this->windSystemConfig->getFilters(); if (empty($filters) || empty($filterChainPath)) return null; if (IS_DEBUG && IS_DEBUG <= WindLogger::LEVEL_DEBUG) { Wind::log( "[core.WindFrontController.getFilterChain] an filter chain defined.(" . $filterChainPath . "," . count($filters) . ")", WindLogger::LEVEL_DEBUG, 'wind.core'); } return $this->windFactory->createInstance($filterChainPath, array($filters)); } protected function initWindFactory() { $configPath = Wind::getRealPath(self::WIND_COMPONENT_CONFIG_RESOURCE); $factoryClass = Wind::import(self::WIND_SYSTEM_FACTORY); $this->windFactory = new $factoryClass(@include ($configPath)); if (IS_DEBUG && IS_DEBUG <= WindLogger::LEVEL_DEBUG) { Wind::log('[core.web.WindFrontController.initWindFactory] system factory:' . self::WIND_SYSTEM_FACTORY, WindLogger::LEVEL_DEBUG, 'wind.core'); } } protected function initWindConfig($appName, $config) { !$appName && $appName = 'default'; $this->windSystemConfig = new WindSystemConfig($config, new WindConfigParser(), $appName); Wind::register($this->windSystemConfig->getRootPath(), $this->windSystemConfig->getAppName(), true); if (IS_DEBUG && IS_DEBUG <= WindLogger::LEVEL_DEBUG) { Wind::log( '[core.web.WindFrontController.initWindConfig] rootPath:' . $this->windSystemConfig->getRootPath() . ' appName:' . $this->windSystemConfig->getAppName(), WindLogger::LEVEL_DEBUG, 'wind.core'); } } protected function beforeProcess() {} protected function afterProcess() { $this->response->sendResponse(); } public function getWindSystemConfig() { return $this->windSystemConfig; } public function getWindFactory() { return $this->windFactory; } public function getRequest() { return $this->request; } public function getResponse() { return $this->response; } }   class WindUrlHelper extends WindModule { const URL_PATTERN = 'url-pattern'; const ROUTE_SUFFIX = 'route-suffix'; const ROUTE_PARAM = 'route-param'; const REWRITE = false; const ROUTE_SEPARATOR = '_'; protected $routeSuffix = ''; protected $routeParam = ''; protected $urlPattern = ''; protected $windRouter = null; public function isRewrite() { return self::REWRITE; } public function parseUrl() { if ((($uri = $this->request->getServer('QUERY_STRING')) == '') || !$this->isRewrite()) return; if (($pattern = $this->getUrlPattern()) == '') return; $seperator = isset($pattern[1]) ? $pattern[1] : $pattern[0]; $uri = explode($seperator, $uri); if (strcasecmp($pattern, "=&") != 0) $params = $this->parseUrlToParams($uri, $seperator, $pattern[0]); $_GET = array_merge($_GET, $params); $this->matchRouter(array_pop($uri)); } public function createUrl($action, $controller, $params = array()) { $action && $this->getWindRouter()->setAction($action); list($_c, $_m) = WindHelper::resolveController($controller); $_c && $this->getWindRouter()->setController($_c); $_m && $this->getWindRouter()->setModule($_m); $url = $this->getWindRouter()->buildUrl(); $server = $this->getUrlServer(); if ($this->isRewrite()) { $server = substr($server, 0, strrpos($server, '/')); $url = $server . $this->buildRewriteURL($params, $url); } else { $url = $server . $url . '&' . $this->buildUrl($params); } return $url; } private function getUrlServer($hasPath = true) { list($protocol, ) = explode('/', $this->request->getProtocol()); $protocol = strtolower($protocol) . '://' . $this->request->getServer('SERVER_NAME'); ($hasPath) && $protocol .= $this->request->getServer('PHP_SELF'); return $protocol; } private function matchRouter($mca) { if (strrpos($mca, '.' . $this->getRouteSuffix()) === false) return; $mca = trim(rtrim($mca, '.' . $this->getRouteSuffix())); if ($mca == '') return; $mca = explode(self::ROUTE_SEPARATOR, $mca); $m = $this->getUrlParamConfig(WindUrlBasedRouter::URL_RULE_MODULE); $c = $this->getUrlParamConfig(WindUrlBasedRouter::URL_RULE_CONTROLLER); $a = $this->getUrlParamConfig(WindUrlBasedRouter::URL_RULE_ACTION); if (count($mca) == 1) { $_GET[$c] = $mca[0]; } elseif (count($mca) == 2) { $_GET[$c] = $mca[0]; $_GET[$a] = $mca[1]; } else { ($mca[0]) && $_GET[$m] = $mca[0]; ($mca[1]) && $_GET[$c] = $mca[1]; ($mca[2]) && $_GET[$a] = $mca[2]; } return; } private function parseUrlToParams($url, $seprator = '', $keyAsValue = '=') { $params = array(); if ($seprator == $keyAsValue) { $n = count($url); for ($i = 0; $i < $n / 2; $i++) { $k = 2 * $i; $v = $k + 1; if (isset($url[$v])) { $this->parseKey($params, $url[$k], $url[$v]); } } return $params; } foreach ((array) $url as $key => $value) { if (strpos($value, $keyAsValue) === false) continue; list($key, $value) = explode($keyAsValue, $value); $this->parseKey($params, $key, $value); } return $params; } private function parseKey(&$params, $key, $value) { if (($pos = strpos($key, '[')) === false || ($pos2 = strpos($key, ']', $pos + 1)) === false) { $params[$key] = $value; return; } $name = substr($key, 0, $pos); if ($pos2 === $pos + 1) { $params[$name][] = $value; return; } else { $key = substr($key, $pos + 1, $pos2 - $pos - 1); $params[$name][$key] = $value; return; } } private function getUrlParamConfig($type) { $_config = $this->getWindRouter()->getConfig(WindUrlBasedRouter::URL_RULE); if ($_param = $this->getConfig($type, WindUrlBasedRouter::URL_PARAM, $_config)) { return $_param; } return $type; } private function getSeparator() { (($pattern = $this->getUrlPattern()) == '') && $pattern = '=&'; $separator = isset($pattern[1]) ? $pattern[1] : $pattern[0]; return array($pattern[0], $separator); } private function buildRewriteURL($params, $routerInfo) { $routerInfo = $this->parseUrlToParams(explode('&', trim($routerInfo, '?')), '&', '='); $routerInfo = implode(self::ROUTE_SEPARATOR, $routerInfo) . '.' . $this->getRouteSuffix(); $separator = $this->getSeparator(); if (empty($params)) return $separator[1] . $routerInfo; $url = ''; foreach ((array) $params as $key => $value) { $url .= $this->buildKey($key, $value, $separator[0], $separator[1]) . $separator[1]; } return $separator[1] . $url . $routerInfo; } private function buildKey($parentKey, $parentValue, $keyAsValue, $separator, $flag = false) { $flag && $parentKey = is_numeric($parentKey) ? '[]' : '[' . $parentKey . ']'; if (!is_array($parentValue)) return $parentKey . $keyAsValue . urlencode($parentValue); $keys = array(); foreach ($parentValue as $key => $value) { $keys[] = $parentKey . $this->buildKey($key, $value, $keyAsValue, $separator, true); } return implode($separator, $keys); } private function buildUrl($params) { if (empty($params)) return ''; $url = ''; foreach ((array) $params as $key => $value) { $url .= $this->buildKey($key, $value, '=', '&', false) . '&'; } return trim($url, '&'); } public function checkUrl($url) { list($protocal, $serverName) = explode('://', $this->getUrlServer(false)); $pos1 = stripos($url, $protocal); $pos2 = stripos($url, $serverName); if (false === $pos1 && false === $pos2) return $protocal . '://' . $serverName . '/' . ltrim($url, '/'); if (false === $pos1) return $protocal . '://' . ltrim($url, '/'); return $url; } public function getRouteSuffix() { if ($this->routeSuffix === '') { $this->routeSuffix = $this->getConfig(self::ROUTE_SUFFIX, WindSystemConfig::VALUE); } return $this->routeSuffix; } public function getRouteParam() { if ($this->routeParam === '') { $this->routeParam = $this->getConfig(self::ROUTE_PARAM, WindSystemConfig::VALUE); } return $this->routeParam; } public function getUrlPattern() { if ($this->urlPattern === '') { $this->urlPattern = $this->getConfig(self::URL_PATTERN, WindSystemConfig::VALUE); } return $this->urlPattern; } public function setRouteSuffix($routeSuffix) { $this->routeSuffix = $routeSuffix; } public function setRouteParam($routeParam) { $this->routeParam = $routeParam; } public function setUrlPattern($urlPattern) { $this->urlPattern = $urlPattern; } public function getWindRouter() { return $this->windRouter; } public function setWindRouter($windRouter) { $this->windRouter = $windRouter; } }    class WindWebApplication extends WindModule implements IWindApplication { protected $dispatcher = null; protected $handlerAdapter = null; public function processRequest() { try { if (IS_DEBUG && IS_DEBUG <= WindLogger::LEVEL_DEBUG) { Wind::log('[core.web.WindWebApplication.processRequest]', WindLogger::LEVEL_DEBUG, 'wind.core'); } $handler = $this->getHandler(); call_user_func_array(array($handler, 'preAction'), array($this->handlerAdapter)); $forward = call_user_func_array(array($handler, 'doAction'), array($this->handlerAdapter)); call_user_func_array(array($handler, 'postAction'), array($this->handlerAdapter)); $this->doDispatch($forward); } catch (WindActionException $actionException) { $this->sendErrorMessage($actionException); } catch (WindDbException $dbException) { $this->sendErrorMessage($dbException->getMessage()); } catch (WindViewException $viewException) { throw new Exception($viewException->getMessage()); } } public function doDispatch($forward) { if ($forward === null) { Wind::log('[core.web.WindWebApplication.doDispatch] Forward is null, dispatch abort.', WindLogger::LEVEL_DEBUG, 'wind.core'); return; } $this->getDispatcher()->dispatch($this, $forward, $this->handlerAdapter); } protected function getHandler() { $handler = $this->getHandlerAdapter()->doParse(); if (IS_DEBUG && IS_DEBUG <= WindLogger::LEVEL_DEBUG) { Wind::log('[core.web.WindWebApplication.getHandler] router result:' . $handler, WindLogger::LEVEL_DEBUG, 'wind.core'); } if (!$this->getSystemFactory()->checkAlias($handler)) { $definition = new WindClassDefinition(); $definition->setPath($handler); $definition->setScope(WindClassDefinition::SCOPE_SINGLETON); $definition->setAlias($handler); $definition->setProxy('true'); $definition->setProperties( array('errorMessage' => array('ref' => COMPONENT_ERRORMESSAGE), 'forward' => array('ref' => COMPONENT_FORWARD), 'urlHelper' => array('ref' => COMPONENT_URLHELPER))); $this->getSystemFactory()->addClassDefinitions($definition); } return $this->getSystemFactory()->getInstance($handler); } protected function sendErrorMessage($actionException) { $_tmp = is_object($actionException) ? $actionException->getError() : $actionException; if (is_string($_tmp)) $_tmp = new WindErrorMessage($_tmp); $forward = $this->getSystemFactory()->getInstance(COMPONENT_FORWARD); $forward->forwardAnotherAction($_tmp->getErrorAction(), $_tmp->getErrorController()); $this->getRequest()->setAttribute('error', $_tmp->getError()); $this->doDispatch($forward); } protected function getHandlerAdapter() { return $this->_getHandlerAdapter(); } protected function getDispatcher() { return $this->_getDispatcher(); } }   class WindEnableValidateModule extends WindModule { protected $_validatorClass = 'WIND:component.utility.WindValidator'; protected $errorController = ''; protected $errorAction = ''; private $_validator = null; private $_errors = array(); private $_defaultMessage = 'the field validate fail.'; public function getErrors() { return $this->_errors; } public function getErrorControllerAndAction() { return array( $this->errorController, $this->errorAction); } protected function validateRules() { return array(); } public function validate(&$input) { if (is_array($input)) $this->validateArray($input); elseif (is_object($input)) $this->validateObject($input); } private function validateArray(&$input) { $rules = $this->validateRules(); foreach ((array) $rules as $rule) { $_input = isset($input[$rule['field']]) ? $input[$rule['field']] : ''; $arg = (array) $rule['args']; array_unshift($arg, $_input); if (call_user_func_array(array( $this->getValidator(), $rule['validator']), $arg) !== false) continue; if ($rule['default'] === null) { $this->_errors[$rule['field']] = $rule['message']; continue; } $input[$rule['field']] = $rule['default']; } } private function validateObject(&$input) { $rules = $this->validateRules(); $methods = get_class_methods($input); foreach ((array) $rules as $rule) { $getMethod = 'get' . ucfirst($rule['field']); $_input = in_array($getMethod, $methods) ? call_user_func(array( $input, $getMethod)) : ''; $arg = (array) $rule['args']; array_unshift($arg, $_input); if (call_user_func_array(array( $this->getValidator(), $rule['validator']), $arg) !== false) continue; if ($rule['default'] === null) { $this->_errors[$rule['field']] = $rule['message']; continue; } $setMethod = 'set' . ucfirst($rule['field']); in_array($setMethod, $methods) && call_user_func_array(array( $input, $setMethod), array( $rule['default'])); } } protected function setValidator($validator) { $this->_validator = $validator; } protected function getValidator() { if ($this->_validator === null) { $_className = Wind::import($this->_validatorClass); Wind::import('WIND:core.factory.WindFactory'); $this->_validator = WindFactory::createInstance($_className); if ($this->_validator === null) throw new WindException('validator', WindException::ERROR_RETURN_TYPE_ERROR); } return $this->_validator; } }   class WindHelper { public static function resolveController($controllerPath) { $_m = $_c = ''; if (!$controllerPath) return array($_c, $_m); if (false !== ($pos = strrpos($controllerPath, '.'))) { $_m = substr($controllerPath, 0, $pos); $_c = substr($controllerPath, $pos + 1); } else { $_c = $controllerPath; } return array($_c, $_m); } } ?>